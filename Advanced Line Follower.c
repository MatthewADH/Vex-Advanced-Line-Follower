#pragma config(Sensor, in1,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in2,    midLine,        sensorLineFollower)
#pragma config(Sensor, in3,    rightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  pbtn,           sensorTouch)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightMotor,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           clawLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           clawOpen,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//------------------------------------------------------------------------------------------------------------------------------------------------------
/*
INTRODUCTION
	This program was written to control a Line Following Claw Bot. The robot uses a 393motor for the right wheels, a 393 motor for the left wheels,
a 393 motor to raise and lower the claw, and a 393 motor to open and close the claw. Three line follower sensors are on the front and a bump switch
This program was written with the intention of real time toggling of the power status, and the driving mode, switching between manual
driving mode (joystick) and automatic driving mode (line following.) The power can be toggled with either the bump switch or a button on the
joystick. The driving mode is Toggl able with a button on the joystick. As the infrastructure already existed, a calibration button on the
joystick was added because no extra work was needed to add this useful feature.
	To accomplish the above objectives, it was necessary to use the advanced programing method of multi-tasking. Functions were also heavily
used due to the fact that functions make the programing much easier to write and read.

	I hope that my commenting and explanations make this program relatively easily understandable. My intention is for this program to be
used as a helpful educational tool for learning programing Vex with ROBOTC.

		Matthew Duffell-Hoffman

CREDITS
	It would be wrong of me to insert my name without those of my teammates who made this project possible. Dylan Goshorn is the amazing builder who
helped with the mechanical side of this project. It would have been impossible to complete this project without Kevin Cook's incredible understanding
of programing. Michael Duffell-Hoffman also helped me to understand some of the finer points of programing.

NOTE
In the comments on the program I name the joystick buttons with names from Xbox controllers (because I think that that might be helpful.) Example: Btn8U = Y or Btn6U = RB
*/

//------------------------------------------------------------------------------------------------------------------------------------------------------

//Variables

int left;																	//Variable used in the calculation of the "threshold." Set to the value the left line follower sensor.
int right;																//Variable used in the calculation of the "threshold." Set to the value the right line follower sensor.
int mid;																	//Variable used in the calculation of the "threshold." Set to the value the middle line follower sensor.
int thresh;																//short for "threshold"; Variable used in the "automatic" line following function to test if the sensor sees black or white. If the sensor is a higher value, it is seeing black.
int speed;																//Variable used to easily change the speed of the "automatic" line following function. Set in the "setUp" function.
bool power;																//Variable to change power status. False=off, True=on. Can be switched by bump switch "pbtn" or Btn8U/Y on joystick
bool mode;																//Variable to change driving mode status. false="manual" or joystick control, true="automatic" or line following mode
bool setUpTest;														//Variable used to prevent "setUp" (mostly just "calibration") from running multiple times if task main restarts. false=not run, true=run.

//-----------------------------------------------------------------------------------------------------------------------------------------------------

//Level 2 Function (functions used in other functions)

void turnLeft () {													//Function used to turn robot left at speed "speed." Used in "automatic" line following function.
	motor(rightMotor)= speed;
	motor(leftMotor)= 0;
}
void turnRight () {												//Function used to turn robot right at speed "speed." Used in "automatic" line following function.
	motor(rightMotor)= 0;
	motor(leftMotor)= speed;
}
void turnStraight () {											//Function used to move robot fowards at speed "speed." Used in "automatic" line following function.
	motor(rightMotor)= speed;
	motor(leftMotor)= speed;
}
void turnStop () {													//Function used to stop the robot. Used when switching out of "automatic" and "power" off
	motor (rightMotor)= 0;
	motor (leftMotor)= 0;
}
void calibrate () {												//Function to set threshold to the midpoint of black and white.
	left=(SensorValue(leftLine));						//Varialbes left, right, and mid are set to the values of their respective line follower sensors
	right=(SensorValue(rightLine));
	mid=(SensorValue(midLine));
	thresh=((((left+right)/2)+mid)/2);			//Averages the left and right (wite), and then averages that with the middle (black)
}

//------------------------------------------------------------------------------------------------------------------------------------------------------

//Level 1 Functions

void setUp() {														//Function that runs at the beginning of the program
	if (setUpTest==false) {									//this if statement is used to make sure the function can only run once. this is to insure that if the task main restarts, which I found to be possible while using multi-tasking.
		speed=(40);														//sets the speed of the "automatic" line following function. Change the variable here.
		calibrate();													//runs the "calibrate" function to set "threshold." This would be the issue if "setUp" ran more than once.
		setUpTest=true;												//sets the "setUpTest" variable to true, so the if statement at the top won't allow the function to run again
	}
}
void manual () {													//this function maps the joystick controls to control the robot in "manual" driving mode
	if (power==true) {											//prevents function from working while "power" is off
		motor[rightMotor]=vexRT[Ch2];					//maps "motorRight" to right analog stick
		motor[leftMotor]=vexRT[Ch3];					//maps "motorLeft" to the left analog stick
		if (vexRT[Btn6U] == 1) {							//raises the claw when Btn6U/RB is pushed
			motor(clawLift)=127;
		}
		else if (vexRT[Btn6D] == 1) {					//lowers the claw when Btn6D/RT is pressed
			motor(clawLift)=-127;
		}
		else {																//stops the "clawLift" motor when neither button is pushed
			motor(clawLift)=0;
		}

		if (vexRT[Btn5D]==1) {								//closes claw when Btn5D/LT is pressed
			motor(clawOpen)=-63;
		}
		else if (vexRT[Btn5U]==1) {						//opens claw when Btn5U/LB is pressed
			motor(clawOpen)=63;
		}
		else {																//stops "clawOpen" motor when neither button is pressed
			motor(clawOpen)=0;
		}
	}
	else {																	//when power is cut, all motors are stopped
		turnStop();
		motor(clawLift)=0;
		motor(clawOpen)=0;
	}
}
void automatic() {												//function to control robot when in line following mode, or "automatic"
	if (SensorValue(midLine) > thresh) {		//when middle sensor sees black, the robot drives fowards
		turnStraight();
	}
	else if (SensorValue(leftLine) > thresh){				//when the left sensor sees black, the robot turns left
		turnLeft();
	}
	else if (SensorValue(rightLine) > thresh) {			//when the right sensor sees black, the robot turns right
		turnRight();
	}
	else {																	//if anything else (i.e. two sensors see black or no sensors see black, the robot moves fowards
		turnStraight();
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------------

//Tasks

task listen() {														//this task is a listener. listeners have the job of listening for buttons to be pushed. It can hear the buttons no matter what the rest of the program is doing.
	while (1==1) {													// infinite loop keeps the "listener" running
		if (SensorValue(pbtn) == 1) {					//when "pbtn," the bump switch, is pushed...
			if (power==false) {									//checks current status of "power" variable and then changes it.
				power=true;
			}
			else {
				power=false;
			}
			wait1Msec(500);											//0.5 second delay to make sure the program only reads one button push
		}
		if (vexRT[Btn8U]==1) {								//carries out the same process as the "pbtn" when Btn8U/Y is pressed
			if (power==false) {
				power=true;
			}
			else {
				power=false;
			}
			wait1Msec(500);
		}
		if (vexRT[Btn8D] == 1) {							//carries out the same process as the "pbtn," but for the "mode" variable, when Btn8D/A is pressed
			if (mode==false) {
				mode=true;
			}
			else {
				mode=false;
			}
			wait1Msec(500);
		}
		if (vexRT[Btn8R]==1) {								//runs the "calibrate" function when Btn8R/B is pressed
			calibrate();
			wait1Msec(250);
		}
	}
	wait1Msec(10);
}
task main(){															//task main ties together the parts of the program previously defined as functions and tasks.
	wait1Msec(100);
	setUp ();																//runs the "setUp" function to "calibrate" the "threshold" and set "speed" of "automatic"
	startTask(listen);											//starts the "listener" task to listen for the power, mode, or calibrae buttons being pressed
	while (1==1) {
		if (power==true){											//only runs when the "power" is on
			if (mode==false) {									//when "mode" is set to false
				manual ();												//runs the "manual" driving function
			}
			else {														//otherwise, when "mode" is set to true
				automatic ();										//runs the "automatic" driving function
			}
		}
		else {															//when "power" is off,
			turnStop ();											//the motors are stopped
		}
	}
	wait1Msec(10);
}
